// Finite Element Method: Time dependent Schr√∂dinger equation in 2D
// Double Slit, wave packet

real L = 10.0;  

real hbar = 1.0; 
real m    = 1.0; 

complex imaginary = 0. + 1.0i;
int npoints = 200;    // mesh points
real dt = 0.05;       // temporal loop

// ----- BOUNDARY DEFINITIONS -----
border lower(t=0,L) { x = t; y = 0; label=1; };
border right(t=0,L) { x = L; y = t; label=1; };
border upper(t=L,0) { x = t; y = L; label=1; };
border left(t=L,0) { x = 0; y = t; label=1; };

// ----- MESH -----
mesh Th = buildmesh(lower(npoints) + right(npoints) + upper(npoints) + left(npoints));
plot(Th, wait=1);

fespace Vh(Th, P1); // real space
Vh<complex> u, v, uu; // complex functions
Vh ur; 
Vh Vplot; 
Vh urplot; 

real slitX = L/2;         // barrier position
real slitWidth = 0.05;    // barrier width
real aperture = 0.3;      // double slit height
real slitGap  = 1.0;      // double slit centers distance 
real barrierHeight = 1e2; // infinite barrier

// centers of the slits
real y1 = L/2 - slitGap/2;
real y2 = L/2 + slitGap/2;

// definition of the potential
func V = ( abs(x - slitX) < slitWidth
           && ! ( (y > y1 - aperture/2 && y < y1 + aperture/2)   // rendija 1
                ||(y > y2 - aperture/2 && y < y2 + aperture/2) ) ) 
         ? barrierHeight : 0.0;

Vplot = V;   // projection to the finite element space



problem schrodinger(u,v)
    = int2d(Th)(u*v + (imaginary*dt/4.0)*(dx(u)*dx(v)+dy(u)*dy(v))+ (imaginary*dt/2.0)*V*u*v)
    + int2d(Th)(-uu*v +(imaginary*dt/4.0)*(dx(uu)*dx(v)+dy(uu)*dy(v)) - (imaginary*dt/2.0)*V*uu*v )
    + on(1, u=0);


real t=0;
real x0 = 2.50;      // center at x
real y0 = 5.0;      // center at y
real sigmax = 0.5;   // wave packet width
real sigmay = 3.0; 
real kx = 10.0;     // wave number at x
real ky = 0.0;      // wave number at y

uu = exp(-((x-x0)^2)/(2*sigmax^2)) * exp(-((y-y0)^2)/(2*sigmay^2)) * exp(imaginary*(kx*x));
real norm = sqrt(int2d(Th)(abs(uu)^2));
uu = uu / norm;

// ---- Define the time steps to save ----
real[int] timesToSave(4);
timesToSave[0] = 0.05;
timesToSave[1] = 0.50;
timesToSave[2] = 1.05;
timesToSave[3] = 2.0;
int Nsave = timesToSave.n;

// ---- temporal loop ----
for (int m = 0; m <= 3/dt; m++) {
    t = t + dt;

    // Solve the temporal loop
    schrodinger;
    uu = u;

    // Calculate the modulus and add the potential
    ur = abs(u);
    urplot = ur + (Vplot/barrierHeight);

    // Show evolution
    plot(urplot, wait=false, fill=true, value=false, cmm="t = " + t);

    // Save png
    for (int i = 0; i < Nsave; i++) {
        if (abs(t - timesToSave[i]) < dt/2) { // tolerancia temporal
            string imagename = "frame_t" + t + ".png";
            plot(urplot, cmm="t = " + t, fill=true, value=false, wait=false, pdf="frame_t" + t + ".pdf");
            cout << "Guardado: " << imagename << endl;
        }
    }
}