// Finite Element Method: Time independent Schrodinger equation in 2D
// Infinite Square Well


real L=1.0;  	// declare variable L to be real
			   // and assign a value to it

real hbar = 1.0545718e-34; // (J·s)
real m    = 9.10938356e-31; // (kg)

int npoints= 50; 	// declare variable npoints to be integer
					// and assign a value to it
					// npoints is the number of mesh points per 
					// unit length of the boundary we want to have
					// more points -> slower but more accurate results

int N=20; // number of  eigenvalues we want to compute
real[int] Evalues(N); // an array of N real numbers parametrised by integers
					// in Freefem++, indices of an array of length N
					// run from 0 to N-1
real t; 	// real uninitialised variable used later
///// END OF DECLARATIONS so far, some more to come later /////
//
///// BOUNDARY DEFINITIONS /////
// just use parametric curve definitions, going in COUNTERCLOCKWISE direction
// (t=t0,t1) in lines below means that t changes from t0 to t1 for this piece
border lower(t=0,L) { x = t; y = 0; label=1; };
border right(t=0,L) { x = L; y = t; label=1; };
border upper(t=L,0) { x = t; y = L; label=1; };
border left(t=L,0) { x = 0; y = t; label=1; };
// label=1; part can be omitted here but will be useful in other examples
///// END OF BOUNDARY DEFINITIONS /////
//
///// create mesh using buildmesh command
///// format of argument: boundary_piece_defined_by_border(number_of_mesh_points)+...
mesh Th=buildmesh(lower(npoints*L)+right(npoints)+upper(npoints*L)+left(npoints));
///// END OF BOUNDARY DEFINITIONS /////
//
//// VISUALISE THE MESH, may be commented out
plot(Th,wait=1);
//
// DECLARE THE FEM SPACE AND FEM VARIABLES 
fespace Vh(Th,P2);
Vh u,v;
//
// DECLARE THE QUADRATIC FORMS
varf a(u,v) = (int2d(Th)( (hbar^2/(2*m))*(dx(u)*dx(v) + dy(u)*dy(v)) )
            + on(1, u=0));
// Dirichlet boundary conditions affect this matrix, so they are applied here using 'on(...)'.
// If no boundary conditions are specified, FreeFEM assumes homogeneous Neumann by default.

varf b(u,v)=int2d(Th)(u*v);
// 'b(v)' represents the right-hand side (∫ f*v) and does not need boundary conditions, 
// because Dirichlet effects are already incorporated in the matrix 'a(u,v)'.
// CREATE THE MATRICES 	   
matrix A = a(Vh,Vh,solver=sparsesolver, tgv=-1);// details of which linear algebra 
					// solver to use for inverting A are in Freefem++ manual
matrix B = b(Vh,Vh, tgv=-1);
//
// DECLARE THE ARRAY TO HOLD EIGENFUNCTIONS
Vh[int] Efunctions(N);
//
// SOLVE THE PROBLEM
int k=EigenValue(A,B,sym=true,sigma=0,value=Evalues,vector=Efunctions);
//
// PRINT THE EIGENVALUES
cout << Evalues;
// 
// --- PROBABILITY DENSITY ARRAY ---
Vh[int] Eprobability(N);

// --- CONSTRUCT THE DENSITIES ---
for (int i=0; i<k; i++) {
    Eprobability[i] = Efunctions[i]^2;  // |ψ|²
}

// ---- EV CONVERSION (eV) ----
real eV = 1.602176634e-19;
real Lphys = 1e-9;           // 1 nm
real[int] EvaluesEV(k);

for (int i = 0; i < k; i++) {
    EvaluesEV[i] = Evalues[i] / (eV*Lphys*Lphys);
}

cout << "Eigenvalues (eV) = " << EvaluesEV << endl;
// PLOT THE 6th EIGENFUNCTION
plot(Eprobability[0], value=true, fill=true, wait=1);
plot(Eprobability[1], value=true, fill=true, wait=1);
plot(Eprobability[2], value=true, fill=true, wait=1);
plot(Eprobability[3], value=true, fill=true, wait=1);
plot(Eprobability[4], value=true, fill=true, wait=1);
plot(Eprobability[5], value=true, fill=true, wait=1);
plot(Eprobability[6], value=true, fill=true, wait=1);
plot(Eprobability[7], value=true, fill=true, wait=1);
plot(Eprobability[8], value=true, fill=true, wait=1);
plot(Eprobability[9], value=true, fill=true, wait=1);
plot(Eprobability[10], value=true, fill=true, wait=1);

