load "tetgen"
load "medit"
load "MUMPS"

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]); 

// a parametrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);

//  partiel derivative of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;

// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;

real vv= 1/square(hh);

verbosity=2;

Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);

verbosity=2;

// construction of the surface of spheres
real Rmin  = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

//FIRST SPHERE

meshS ThS=movemesh23(Th,transfo=[f1min,f2min,f3min]);
cout << " labels S = " << labels(ThS)<< endl; 
real[int] domain = [0.,0.,0.,145,0.01];
mesh3 Th3sph=tetg(ThS,switch="paAAQYY",nbofregions=1,regionlist=domain);


//SECOND SPHERE

int[int] newlabel = [145,18];
real[int] domainrefine = [0.,0.,0.,145,0.0001];
mesh3 Th3sphrefine=tetgreconstruction(Th3sph,switch="raAQ",region=newlabel,nbofregions=1,regionlist=domainrefine,sizeofvolume=0.0001);
Th3sphrefine=change(Th3sphrefine,flabel=1);




// THIRD SPHERE

int[int] newlabel2 = [145,53];
func fsize = 0.0048/(( 1 + 5*sqrt( (x-0.5)^2+(y-0.5)^2+(z-0.5)^2) )^3);
mesh3 Th3sphrefine2=tetgreconstruction(Th3sph,switch="raAQ",region=newlabel2,sizeofvolume=fsize);
Th3sphrefine2=change(Th3sphrefine2,flabel=1);

// To make sure which is the label of the boundary
for(int i = 0; i < Th3sphrefine2.nbe; i++){
    cout << "Cara " << i << " : label = " << Th3sphrefine2.be(i).label << endl;
}



//medit("sphere",Th3sph,wait=1);
//medit("sphererefinedomain",wait=1,Th3sphrefine);
medit("sphererefinelocal",wait=1,Th3sphrefine2);




// ---------------------------
// Constants
// ---------------------------
real me=9.10938356e-31;           // electron mass
real planckh=6.62607004e-34;
real hbar=1.0545718e-34;
real kgm2Ds2ToeV=6.24150636309e18;
real qe=1.6021766208e-19;         // electron charge
real a0=5.2917721039e-11;         // Bohr radius
real varepsilon0=8.854187817e-12; // permitivity


// ---------------------------
// Function space
// ---------------------------
fespace Vh(Th3sphrefine2,P1);
Vh Psi, v;

int nev=20;
real tilE=-2e-18;
Vh[int] EigenPsi(nev);
real[int] EigenVal(nev);
real R=20*a0;

// ---------------------------
// Variational Problem (Scalated)
// ---------------------------
varf Schrodinger(Psi,v) =
    int3d(Th3sphrefine2)( hbar^2/(2*me*R*R)*(dx(Psi)*dx(v) + dy(Psi)*dy(v) + dz(Psi)*dz(v)) )
  - int3d(Th3sphrefine2)( qe^2/(4*pi*varepsilon0*R*sqrt(x^2+y^2+z^2))*Psi*v )
  - int3d(Th3sphrefine2)(tilE*Psi*v) 
  + on(1,Psi=0);

varf RHS(Psi,v) = int3d(Th3sphrefine2)(Psi*v);

matrix A = Schrodinger(Vh,Vh,solver="SPARSESOLVER");
matrix B = RHS(Vh,Vh,solver=CG,eps=1e-20);

// ---------------------------
// Problem resolution
// ---------------------------
int num = EigenValue(A,B,sym=true,sigma=tilE,
                     value=EigenVal,vector=EigenPsi,
                     tol=1e-20,maxit=2000,ncv=0);

// ---------------------------
// Results
// ---------------------------
for(int i = 0; i < nev; i++){
    cout << "Eigenvalue["<<i<<"] = " << EigenVal[i]
         << " J , Energy level: " << EigenVal[i]*kgm2Ds2ToeV << " eV" << endl;
}

Vh Psi11 = EigenPsi[5];
Vh rho = Psi11^2;

ofstream fout("rho1s.txt");
for (int i=0; i<Vh.ndof; i++){
    fout << Th3sphrefine2(i).x << " "
         << Th3sphrefine2(i).y << " "
         << Th3sphrefine2(i).z << " "
         << rho[][i] << endl;
}


