// ==========================================================
//  Finite Element Method: Time dependent Schrödinger equation in 2D
//  Infinite Square Well with central barrier
// ==========================================================

real L = 12.0;  
real hbar = 1.0; 
real m = 1.0; 
complex imaginary = 0. + 1.0i;
int npoints = 200;    // mesh points
real dt = 0.05;       // time step

// ----- BOUNDARY DEFINITIONS -----
border lower(t=0,L) { x = t; y = 0; label=1; };
border right(t=0,L) { x = L; y = t; label=1; };
border upper(t=L,0) { x = t; y = L; label=1; };
border left(t=L,0) { x = 0; y = t; label=1; };

// ----- MESH -----
mesh Th = buildmesh(lower(npoints) + right(npoints) + upper(npoints) + left(npoints));
plot(Th, wait=1);

fespace Vh(Th, P1);       // real space
Vh<complex> u, v, uu;     // complex functions
Vh ur;
Vh Vplot;
Vh urplot;

// ----- POTENTIAL -----
real slitX = L/2;         // barrier position
real slitWidth = 0.05;    // barrier width
real barrierHeight = 100; //  "infinite"  height simulation

func V = (abs(x - slitX) < slitWidth) ? barrierHeight : 0.0;
Vplot = V;

// ----- SCHRÖDINGER PROBLEM -----
problem schrodinger(u, v)
    = int2d(Th)(u*v + (imaginary*dt/4.0)*(dx(u)*dx(v) + dy(u)*dy(v)) 
                + (imaginary*dt/2.0)*V*u*v)
    + int2d(Th)(-uu*v + (imaginary*dt/4.0)*(dx(uu)*dx(v) + dy(uu)*dy(v)) 
                + (imaginary*dt/2.0)*V*uu*v)
    + on(1, u=0);

// ----- INITIAL CONDITION -----
real t = 0;
real x0 = 2.50;      // center at x
real y0 = 5.0;       // center at y
real sigma = 0.5;    // packet width
real kx = 10.0;      // wave number at x
real ky = 0.0;       // wave number at y

uu = exp(-((x - x0)^2 + (y - y0)^2) / (2 * sigma^2)) * exp(imaginary * (kx*x + ky*y));
real norm = sqrt(int2d(Th)(abs(uu)^2));
uu = uu / norm;

// ----- TIMES TO SAVE -----
real[int] timesToSave(4);
timesToSave[0] = 0.05;
timesToSave[1] = 0.2;
timesToSave[2] = 0.7;
timesToSave[3] = 1.4;
int Nsave = timesToSave.n;

// ----- TIME EVOLUTION LOOP -----
for (int m = 0; m <= 3/dt; m++) {
    t = t + dt;

    // Solve the temporal step
    schrodinger;
    uu = u;

    // Calculate the modulus and sum the potential (to visualize)
    urplot = ur + (Vplot / barrierHeight);

    // Show the time evolution 
    plot(urplot, wait=false, fill=true, value=false, cmm="t = " + t);

    // Save png
    for (int i = 0; i < Nsave; i++) {
        if (abs(t - timesToSave[i]) < dt/2) { // tolerancia temporal
            string imagename = "frame_t" + t + ".png";
            plot(urplot, cmm="t = " + t, fill=true, value=false, wait=false, ps=imagename);
            cout << "Guardado: " << imagename << endl;
        }
    }
}
